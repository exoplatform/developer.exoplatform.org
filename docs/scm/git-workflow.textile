---
title: "Git - Workflow"
tags: [git,workflow]
group: scm
---

<div class="row">
  <div class="col-md-12">

Our workflow is built on two principles :
* The *branching model* that has to be followed by *all projects* at eXo
* The *repository architecture* (development vs blessed) that has to be followed by *all projects involved in products* produced eXo (and thus that require to be supported).

h2. Branching model

Branching model is quite simple, there are 4 kinds of branch :
* @master@ : Master branch is used as main branch where long term developments are done.
* @feature/xxx@ : Feature branches are dedicated branch for one big feature (lot of commits), "xxx" is the feature name.
* @stable/xxx@ : Stable branch are used to perform releases and write / accept fix. "xxx" is the stable version name (e.g 1.0.x).
* @fix/yyy/xxx@ : Fix branch is dedicated to integrate bugfix on stable branch "yyy". When the branch is ready, a pull request will be done. "xxx" could be for example "PROJECT-12345" and "yyy" could be "1.0.x".

h2. Repository architecture

<div class="row">
  <div class="span3">
Aiming security and backup purpose, we are using two repository kinds (owned by two distinct github organizations).
These are @blessed@ and @development@ repositories hosted respectively on "exoplatform":https://github.com/exoplatform and "exodev":https://github.com/exodev organizations.
Development repositories are forked from blessed repositories.
*This strategy is applied to all repositories/projects involved in eXo products.* Others projects are using a single repository hosted on "exoplatform" organization.
  </div>
  <div class="span5">!/resources/scm/graphics/git-organization.png!</div>
</div>

h2. Branches and repositories

<div class="row">
  <div class="span5">

h3. Development repository

This repository is the developers repository. The main development branch is @master@ branch. Depending the contribution kind (one shot contribution or feature contribution), the developer can use a dedicated @feature@ branch if needed.
The most of development activity will be done in this repository by a lot of contributors :
* @maintainers@ (formerly known as @sl3@) : To develop fix on some stable version. These developments are done in dedicated @fix@ branches (more details below).
* @all development teams@ : To do one shot contribution and handle feature branch life cycle.

In this repository, only @master@ branch will be under CI. 
The CI on feature branch is not supported yet, if you want to have a CI, you will need to merge the branch (only when the branch is stable enough).

  	
h3. Blessed repository

In this repository you can find @stable@ branches and release tags. There is @master@ branch also (as backup).
Only some people are able to write on this repository :
* @maintainers@ : To integrate pull request on stable branches.
* @release manager@ : To perform release operations on stable (supported) branches.
* @keepers@ : Repository keepers are @Project Leader@, @Team Leader@ and @Technical Leader@. They are able to pull changes from dev to blessed when the master is stable enough and they can process releases on master branch for non supported versions of products (alpha, beta, RCs, ...)

The continuous integration is applied on stables branches (@stable/1.0.x@, @stable/1.1.x@, etc). No CI for master on blessed repository.

  </div>
	  <div class="span7">
*Focusing on one set of dev/blessed repository we have the following overview :*
!/resources/scm/graphics/git-branches.png!
		</div>
</div>

h2. Flow

h3. Environment setup

We suppose you are working in the project hosted in the git repository @xxx@
The first time you need create a local clone of the development repository of @xxx@

{% highlight sh %}
git clone git@github.com:exodev/xxx.git
cd xxx
{% endhighlight %}

You may also need to add a remote repository to access to the blessed repository (to create @fix@ branches or if you are a @maintainer@ or a @keeper@)

{% highlight sh %}
git remote add blessed git@github.com:exoplatform/xxx.git
git fetch blessed
{% endhighlight %}

Don't forget to regularly fetch changes from both repositories to keep your synchronization with them.

h3. New feature

When starting work on a new feature, branch off from the master branch.

{% highlight sh %}
git checkout -b feature/my-new-feature master
{% endhighlight %}

You work on this feature : @git add@, @git commit@, ....

Finished features may be merged into the master branch definitely add them to the upcoming release.
You checkout the @master@ branch and update it (from @origin@ repository thus the development repository)

{% highlight sh %}
git checkout master
git pull origin
{% endhighlight %}

You merge all changes you did in the feature branch and push your changes in the development repository

{% highlight sh %}
git merge --no-ff feature/my-new-feature
git push origin master
{% endhighlight %}

The @--no-ff@ flag causes the merge to always create a new commit object, even if the merge could be performed with a fast-forward. This avoids losing information about the historical existence of a feature branch and groups together all commits that together added the feature. Compare:
!/resources/scm/graphics/git-merge-without-ff.png!

In the latter case, it is impossible to see from the Git history which of the commit objects together have implemented a featureâ€”you would have to manually read all the log messages. Reverting a whole feature (i.e. a group of commits), is a true headache in the latter situation, whereas it is easily done if the @--no-ff@ flag was used.

Yes, it will create a few more (empty) commit objects, but the gain is much bigger that that cost.

You can now safely delete your local feature branch and if required the remote one on the development repository if you shared it with others.

{% highlight sh %}
git branch -d feature/my-new-feature
git push origin :feature/my-new-feature
{% endhighlight %}

h3. One shot contribution

One shot contribution is the simplest case. 
Just commit directly on master branch and push it to dev repository.
You checkout the @master@ branch and update it (from @origin@ repository thus the development repository)

{% highlight sh %}
git checkout master
git pull origin
{% endhighlight %}

You work on your contribution : @git add@, @git commit@, ....

You push your commits into the development repository

{% highlight sh %}
git push origin master
{% endhighlight %}

h3. Fix a stable version

Each stable branch on blessed repository can be updated via Pull Request. 
Assuming you are working on issue PROJECT-12345 to fix a problem on @stable/A.B.x@ branch
Before to do you pull request, let's create and publish your fix on dedicated @fix/A.B.x/xxx@ branch on development repository.

Create a local branch to work on the issue from the stable branch

{% highlight sh %}
git checkout -b fix/A.B.x/PROJECT-12345 blessed/stable/A.B.x
{% endhighlight %}

You work on your fix : @git add@, @git commit@, ....

When you are satisfied of the fix you push it on development repository to share it with the team

{% highlight sh %}
git push origin fix/A.B.x/PROJECT-12345
{% endhighlight %}

Now your contribution is pushed in dedicated branch on development repository, you can do a pull request. On github project page (dev repository) click on !/resources/scm/graphics/git-pull-request.png! and ask  the merge from @fix/A.B.x/PROJECT-12345@ (development repository) to @stable/A.B.x@ (blessed repository).

!/resources/scm/graphics/git-pull-request-creation.png!

The pull request must include the link to the Jira issue related to the fix. You have to favor the Jira issue to comment the resolution you did.

Last step is to fill the pull request URL on jira issue. Go to jira issue and fill pull request field :

!/resources/scm/graphics/git-jira-pull-request.png!

If the fix is refused you can push new commits in this branch and the pull request will be automatically updated

h3. Integrate a fix to stable version

When a pull request is submitted @maintainers@ will have to review, validate it and then integrate it into the stable branch.

Assuming you are working on issue PROJECT-12345 to fix a problem on @stable/A.B.x@ branch

You checkout a copy of the stable branch

{% highlight sh %}
git checkout -b blessed/stable/A.B.x
{% endhighlight %}

You merge the content of fix branch into the local stable branch

{% highlight sh %}
git merge --no-ff origin/fix/A.B.x/PROJECT-12345
{% endhighlight %}

You can build and test the change.
At any time you can comment the pull request to ask to the developer to improve it
If you decide to refuse it you comment the Jira issue and the developer will have to send an update of the fix.
You can re-merge the updated fix branch as many time as needed.
When you are satisfied of the fix you push the merge the new stable branch content into the blessed repo.

{% highlight sh %}
git push blessed stable/A.B.x
{% endhighlight %}

The Pull Request is automatically closed by Github when it catches that PR commits are integrated into the target repository/branch.
You resolve/close the PROJECT-12345 issue in Jira.

You can delete the fix branch in the development repo

{% highlight sh %}
git push origin :fix/A.B.x/PROJECT-12345
{% endhighlight %}

h3. Update blessed master branch.

An "automated job":https://ci.exoplatform.org/job/synchronize-dev-blessed-masters/ is responsible to push every days all changes done in the master branch of the development repository into the blessed repository.
If someone pushes in the development repository a non fast-forward change the job won't accept to push it into the blessed repository (It is really not recommended to push in a shared repository a non fast-forward change).
In that exceptionnal case if the team validates this change, a keeper of the blessed repository will have to force the update of the blessed repository.

{% highlight sh %}
git checkout master
git pull origin master
git push --force blessed master
{% endhighlight %}

h3. Perform a release

The release is in charge of @release managers@. 
The release is performed directly on stable branch of a blessed repository.

In that case we consider that you directly fork the blessed repository

{% highlight sh %}
git clone git@github.com:exoplatform/xxx.git
cd xxx
{% endhighlight %}

You checkout the release branch on which you need to perform a release.

{% highlight sh %}
git checkout stable/A.B.x
{% endhighlight %}

You follow the classical maven release process

{% highlight sh %}
mvn release:prepare
mvn release:perform
{% endhighlight %}

h3. Move a release tag

*In really special case* (when the test campaign show a critical issue after tagging but before nexus publishing) release manager still can apply a last minute commit and move the tag.
After your commit, just delete the remote tag, and create another one in this way :

{% highlight sh %}
git tag -d 1.0.0
git push origin :refs/tags/1.0.0
git tag 1.0.0
git push origin 1.0.0
{% endhighlight %}


h3. Master <-> Stabilization branches synchronization

Frequency : Every Monday
By whom : Each team

{% highlight sh %}
# Go into the project directory
cd project-XX
# Update stabilization and master branches from remote
git checkout feature/stabilization; git pull; git checkout master; git pull
# Merge into master changes from stabilization 
git merge feature/stabilization --no-commit --no-ff 
{% endhighlight %}

Analyze changes that will be merged into master and potentially reset useless changes (like wrong pom versions updates)

{% highlight sh %}
# Manually commit the merge (don't be afraid, it might be empty) and push it
git commit; git push
# Checkout the stabilization branch
git checkout feature/stabilization 
# Merge into stabilization changes from master (it might contain a FB previously merged ...)
git merge master --no-commit --no-ff 
{% endhighlight %}

Analyze changes that will be merged into stabilization and potentially reset useless changes (like wrong pom versions updates)

{% highlight sh %}
# Manually commit the merge (don't be afraid, it might be empty) and push it
git commit; git push
{% endhighlight %}
	   
At the end you should have in acceptance sources screen (https://acceptance.exoplatform.org/features.php#stabilization) only one commit ahead and 0 commit behind for the stabilization branch.

h3. Master -> Feature branches updates

Frequency : Regularly (every week ?)
By whom : Each FB responsible team
	  

{% highlight sh %}
# Go into the project directory
cd project-XX
# Update feature and master branches from remote
git checkout master; git pull; git checkout feature/XXXXX; git pull
# Merge into feature branch changes from master (it might contain a FB previously merged ...)
git merge master --no-commit --no-ff
{% endhighlight %}

Analyze changes that will be merged into feature branch and potentially reset useless changes (like wrong pom versions updates)

{% highlight sh %}
# Manually commit the merge (don't be afraid, it might be empty) and push it
git commit; git push
{% endhighlight %}	   

At the end you should have in acceptance sources screen (https://acceptance.exoplatform.org/features.php) 0 commit behind for the feature branch.

  </div><!-- col-md-12 -->
</div><!-- row -->
